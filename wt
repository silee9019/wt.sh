#!/usr/bin/env bash

set -euo pipefail

SCRIPT_PATH="$0"
SCRIPT_NAME="$(basename "$SCRIPT_PATH")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

MARKER_DIR=""
MARKER_FILE=""
WORKTREE_BASE_DIR=""
REPO_DIR=""

die() {
  echo "$SCRIPT_NAME: $*" >&2
  exit 1
}

print_usage() {
  cat <<EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
  list|ls [--porcelain]           List registered worktree directories.
  add <branch> [--path DIR] [--from REF]
                                  Create a new worktree (branch required).
  remove|rm <dir>
                                  Remove a worktree directory.
  move|mv <dir> <new-path>
                                  Move/rename a worktree directory.
  prune [--dry-run]               Prune stale worktree metadata.
  init [dir] [--repo PATH]        Mark a directory for new worktrees; supply --repo when outside the repo.
  help|-h|--help                  Show this help message.

Markers:
  .wt            Created by init; identifies the base directory and primary repo.
EOF
}

trim_whitespace() {
  local str="$1"
  str="${str#"${str%%[![:space:]]*}"}"
  str="${str%"${str##*[![:space:]]}"}"
  printf '%s' "$str"
}

find_marker_base() {
  local dir="$1"

  while :; do
    if [[ -f "$dir/.wt" ]]; then
      (cd "$dir" && pwd)
      return 0
    fi

    if [[ "$dir" == "/" ]]; then
      break
    fi

    dir="$(dirname "$dir")"
  done

  return 1
}

parse_marker_file() {
  local dir="$1"
  local marker="$dir/.wt"
  [[ -f "$marker" ]] || die "Marker file '$marker' is missing."

  local base_path=""
  local repo_path=""
  local line key value
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}"
    line="${line%%$'\r'}"
    line="$(trim_whitespace "$line")"
    [[ -z "$line" ]] && continue

    key="${line%%:*}"
    value="${line#*:}"
    [[ "$key" == "$value" ]] && die "Malformed marker line in '$marker': $line"
    key="$(trim_whitespace "$key")"
    value="$(trim_whitespace "$value")"

    case "$key" in
      base)
        base_path="$value"
        ;;
      repo)
        repo_path="$value"
        ;;
    esac
  done <"$marker"

  [[ -n "$repo_path" ]] || die "Marker file '$marker' does not specify a repository (missing 'repo:')."

  if [[ -n "$base_path" ]]; then
    if [[ "$base_path" != /* ]]; then
      base_path="$(cd "$dir" && cd "$base_path" 2>/dev/null && pwd)" || die "Unable to resolve base path '$base_path' from marker."
    else
      base_path="$(cd "$base_path" 2>/dev/null && pwd)" || die "Base path '$base_path' in marker is not accessible."
    fi
    if [[ "$base_path" != "$dir" ]]; then
      die "Marker base '$base_path' does not match marker location '$dir'."
    fi
  fi

  if [[ "$repo_path" != /* ]]; then
    repo_path="$(cd "$dir" && cd "$repo_path" 2>/dev/null && pwd)" || die "Unable to resolve repo path '$repo_path' from marker."
  else
    repo_path="$(cd "$repo_path" 2>/dev/null && pwd)" || die "Repository path '$repo_path' in marker is not accessible."
  fi

  [[ -e "$repo_path/.git" ]] || die "Repository '$repo_path' is not a git worktree (missing .git)."

  MARKER_DIR="$dir"
  MARKER_FILE="$marker"
  WORKTREE_BASE_DIR="$dir"
  REPO_DIR="$repo_path"
}

ensure_marker_loaded() {
  [[ -n "$REPO_DIR" ]] && return

  local marker_base=""
  if ! marker_base="$(find_marker_base "$PWD")"; then
    die "No .wt marker found. Run '$SCRIPT_NAME init' first."
  fi

  parse_marker_file "$marker_base"
}

auto_detect_repo_dir() {
  local base_dir="$1"

  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "$(git rev-parse --show-toplevel)"
    return 0
  fi

  local candidates=()
  local dir_candidates=()

  if [[ -e "$base_dir/.git" ]]; then
    candidates+=("$(cd "$base_dir" && pwd)")
    if [[ -d "$base_dir/.git" ]]; then
      dir_candidates+=("$(cd "$base_dir" && pwd)")
    fi
  fi

  local entry
  for entry in "$base_dir"/*; do
    [[ -d "$entry" ]] || continue
    [[ -e "$entry/.git" ]] || continue
    candidates+=("$(cd "$entry" && pwd)")
    if [[ -d "$entry/.git" ]]; then
      dir_candidates+=("$(cd "$entry" && pwd)")
    fi
  done

  if [[ "${#dir_candidates[@]}" -eq 1 ]]; then
    echo "${dir_candidates[0]}"
    return 0
  fi

  if [[ "${#dir_candidates[@]}" -gt 1 ]]; then
    die "Multiple repositories (with dedicated .git directories) detected in '$base_dir'. Re-run with --repo PATH."
  fi

  case "${#candidates[@]}" in
    0)
      return 1
      ;;
    1)
      echo "${candidates[0]}"
      return 0
      ;;
    *)
      die "Multiple repositories detected in '$base_dir'. Re-run with --repo PATH."
      ;;
  esac
}

write_marker_file() {
  local base_dir="$1"
  local repo_dir="$2"
  local marker="$base_dir/.wt"

  cat >"$marker" <<EOF
# wt base marker
base: $base_dir
repo: $repo_dir
EOF

  MARKER_DIR="$base_dir"
  MARKER_FILE="$marker"
  WORKTREE_BASE_DIR="$base_dir"
  REPO_DIR="$repo_dir"
}

git_cmd() {
  ensure_marker_loaded
  git -C "$REPO_DIR" "$@"
}

default_start_point() {
  if git_cmd show-ref --verify --quiet "refs/remotes/origin/main"; then
    echo "origin/main"
    return
  fi
  if git_cmd show-ref --verify --quiet "refs/heads/main"; then
    echo "main"
    return
  fi
  git_cmd rev-parse --abbrev-ref HEAD
}

sanitize_path() {
  local name="$1"
  name="${name//[^A-Za-z0-9._-]/-}"
  echo "$name"
}

resolve_worktree_path() {
  local input="$1"

  ensure_marker_loaded

  if [[ -d "$input" ]]; then
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "$WORKTREE_BASE_DIR/$input" ]]; then
    (cd "$WORKTREE_BASE_DIR/$input" && pwd)
    return
  fi

  die "No worktree directory found for '$input'."
}

cmd_list() {
  ensure_marker_loaded
  git_cmd worktree list "$@"
}

cmd_add() {
  ensure_marker_loaded

  local branch=""
  local start_point=""
  local target_path=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path)
        [[ $# -ge 2 ]] || die "--path requires a directory."
        target_path="$2"
        shift 2
        ;;
      --from)
        [[ $# -ge 2 ]] || die "--from requires a ref."
        start_point="$2"
        shift 2
        ;;
      --help|-h)
        print_usage
        exit 0
        ;;
      -*)
        die "Unknown option '$1' for add."
        ;;
      *)
        if [[ -n "$branch" ]]; then
          die "Multiple branch names provided."
        fi
        branch="$1"
        shift
        ;;
    esac
  done

  [[ -n "$branch" ]] || die "Branch name is required."

  if [[ -z "$target_path" ]]; then
    target_path="$WORKTREE_BASE_DIR/$(sanitize_path "$branch")"
  elif [[ "$target_path" != /* ]]; then
    target_path="$WORKTREE_BASE_DIR/$target_path"
  fi

  [[ ! -e "$target_path" ]] || die "Target path '$target_path' already exists."

  if git_cmd show-ref --verify --quiet "refs/heads/$branch"; then
    git_cmd worktree add "$target_path" "$branch"
    return
  fi

  if [[ -z "$start_point" ]]; then
    if git_cmd show-ref --verify --quiet "refs/remotes/origin/$branch"; then
      start_point="origin/$branch"
    else
      start_point="$(default_start_point)"
    fi
  fi

  git_cmd worktree add -b "$branch" "$target_path" "$start_point"
}

cmd_remove() {
  local target=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        print_usage
        exit 0
        ;;
      -*)
        die "Unknown option '$1' for remove."
        ;;
      *)
        if [[ -n "$target" ]]; then
          die "Multiple targets provided."
        fi
        target="$1"
        shift
        ;;
    esac
  done

  [[ -n "$target" ]] || die "Worktree directory is required."

  local resolved
  resolved="$(resolve_worktree_path "$target")"

  git_cmd worktree remove "$resolved"
}

cmd_move() {
  ensure_marker_loaded

  [[ $# -ge 1 ]] || die "Source worktree is required."
  local source="$1"
  shift
  [[ $# -ge 1 ]] || die "Destination path is required."
  local destination="$1"

  local resolved_source
  resolved_source="$(resolve_worktree_path "$source")"

  if [[ "$destination" != /* ]]; then
    destination="$WORKTREE_BASE_DIR/$destination"
  fi

  git_cmd worktree move "$resolved_source" "$destination"
}

cmd_prune() {
  ensure_marker_loaded
  git_cmd worktree prune "$@"
}

cmd_init() {
  local base_arg=""
  local repo_arg=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        [[ $# -ge 2 ]] || die "--repo requires a path."
        repo_arg="$2"
        shift 2
        ;;
      --help|-h)
        print_usage
        exit 0
        ;;
      -*)
        die "Unknown option '$1' for init."
        ;;
      *)
        if [[ -n "$base_arg" ]]; then
          die "Multiple base directories provided."
        fi
        base_arg="$1"
        shift
        ;;
    esac
  done

  local base_dir="${base_arg:-$PWD}"
  if [[ "$base_dir" != /* ]]; then
    base_dir="$PWD/$base_dir"
  fi
  mkdir -p "$base_dir" || die "Failed to create directory '$base_dir'."
  base_dir="$(cd "$base_dir" && pwd)"

  local repo_dir=""
  if [[ -n "$repo_arg" ]]; then
    if [[ "$repo_arg" != /* ]]; then
      repo_arg="$PWD/$repo_arg"
    fi
    repo_dir="$(cd "$repo_arg" 2>/dev/null && pwd)" || die "Unable to resolve repository path '$repo_arg'."
  else
    if ! repo_dir="$(auto_detect_repo_dir "$base_dir")"; then
      die "Unable to detect git repository automatically. Run '$SCRIPT_NAME init [dir] --repo /path/to/repo'."
    fi
  fi

  [[ -e "$repo_dir/.git" ]] || die "Repository '$repo_dir' is not a git worktree (missing .git)."

  local marker="$base_dir/.wt"
  if [[ -e "$marker" && ! -f "$marker" ]]; then
    die "Cannot place marker at '$marker'; remove or rename the existing entry."
  fi

  write_marker_file "$base_dir" "$repo_dir"

  echo "Marked $base_dir for new worktrees (repo: $repo_dir)."
}

main() {
  local command="${1:-help}"
  shift || true

  case "$command" in
    list|ls)
      cmd_list "$@"
      ;;
    add)
      cmd_add "$@"
      ;;
    remove|rm)
      cmd_remove "$@"
      ;;
    move|mv)
      cmd_move "$@"
      ;;
    prune)
      cmd_prune "$@"
      ;;
    init)
      cmd_init "$@"
      ;;
    help|-h|--help)
      print_usage
      ;;
    *)
      die "Unknown command '$command'. Run '$SCRIPT_NAME help' for usage."
      ;;
  esac
}

main "$@"
