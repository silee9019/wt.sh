#!/usr/bin/env bash

set -euo pipefail

SCRIPT_PATH="$0"
SCRIPT_NAME="$(basename "$SCRIPT_PATH")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/.wtconfig"

die() {
  echo "$SCRIPT_NAME: $*" >&2
  exit 1
}

print_usage() {
  cat <<EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
  list|ls|l [--porcelain]         List registered worktrees.
  create|add|new|c <branch> [--path DIR] [--from REF] [--force]
                                  Create a worktree (new branch if missing).
  remove|rm|delete|del|r <path|branch> [--force]
                                  Remove a worktree by path or branch name.
  move|mv|update|m <path|branch> <new-path>
                                  Move/rename a worktree directory.
  prune|p [--dry-run]             Prune stale worktree metadata.
  init [dir]                      Mark a directory for new worktrees (defaults to ".").
  help|-h|--help                  Show this help message.

Environment:
  WORKTREE_REPO  Override auto-detected primary worktree directory.
  WORKTREE_BASE  Override the base directory for new worktrees.
EOF
}

find_marker_base() {
  local dir="$1"

  while :; do
    if [[ -f "$dir/.wt" ]]; then
      (cd "$dir" && pwd)
      return 0
    fi

    if [[ "$dir" == "/" ]]; then
      break
    fi

    dir="$(dirname "$dir")"
  done

  return 1
}

resolve_repo_dir() {
  local repo_dir="${WORKTREE_REPO:-}"

  if [[ -n "$repo_dir" ]]; then
    [[ -d "$repo_dir/.git" ]] || die "WORKTREE_REPO '$repo_dir' is not a git worktree."
    echo "$(cd "$repo_dir" && pwd)"
    return
  fi

  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "$(git rev-parse --show-toplevel)"
    return
  fi

  local marker_base=""
  if marker_base="$(find_marker_base "$PWD")"; then
    local marker_file="$marker_base/.wt"
    if [[ -f "$marker_file" ]]; then
      local repo_path=""
      while IFS='=' read -r key value; do
        case "$key" in
          repo)
            repo_path="$value"
            ;;
        esac
      done <"$marker_file"

      if [[ -n "$repo_path" && -d "$repo_path/.git" ]]; then
        echo "$(cd "$repo_path" && pwd)"
        return
      fi
    fi
  fi

  local candidate
  for candidate in "$SCRIPT_DIR"/*; do
    if [[ -d "$candidate/.git" && -d "$candidate/.git/worktrees" ]]; then
      echo "$(cd "$candidate" && pwd)"
      return
    fi
  done

  die "Unable to locate git repository. Set WORKTREE_REPO to the primary worktree directory."
}

REPO_DIR="$(resolve_repo_dir)"
load_worktree_base_dir() {
  local override="${WORKTREE_BASE:-}"

  if [[ -n "$override" ]]; then
    [[ -d "$override" ]] || die "WORKTREE_BASE '$override' does not exist."
    echo "$(cd "$override" && pwd)"
    return
  fi

  local marker_base=""
  if marker_base="$(find_marker_base "$PWD")"; then
    echo "$marker_base"
    return
  fi

  if [[ -f "$CONFIG_FILE" ]]; then
    local stored
    stored="$(<"$CONFIG_FILE")"
    if [[ -n "$stored" ]]; then
      if [[ -d "$stored" && -f "$stored/.wt" ]]; then
        echo "$(cd "$stored" && pwd)"
        return
      fi
      die "Configured worktree directory '$stored' is invalid. Run '$SCRIPT_NAME init <dir>' to update it."
    fi
  fi

  echo "$SCRIPT_DIR"
}

WORKTREE_BASE_DIR="$(load_worktree_base_dir)"

git_cmd() {
  git -C "$REPO_DIR" "$@"
}

default_start_point() {
  if git_cmd show-ref --verify --quiet "refs/remotes/origin/main"; then
    echo "origin/main"
    return
  fi
  if git_cmd show-ref --verify --quiet "refs/heads/main"; then
    echo "main"
    return
  fi
  git_cmd rev-parse --abbrev-ref HEAD
}

sanitize_path() {
  local name="$1"
  name="${name//[^A-Za-z0-9._-]/-}"
  echo "$name"
}

resolve_worktree_path() {
  local input="$1"

  if [[ -d "$input" ]]; then
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "$WORKTREE_BASE_DIR/$input" ]]; then
    (cd "$WORKTREE_BASE_DIR/$input" && pwd)
    return
  fi

  if [[ "$WORKTREE_BASE_DIR" != "$SCRIPT_DIR" && -d "$SCRIPT_DIR/$input" ]]; then
    (cd "$SCRIPT_DIR/$input" && pwd)
    return
  fi

  local current_path=""
  local branch_name=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_path="${line#worktree }"
        ;;
      branch\ refs/heads/*)
        branch_name="${line#branch refs/heads/}"
        if [[ "$branch_name" == "$input" ]]; then
          echo "$current_path"
          return
        fi
        ;;
    esac
  done < <(git_cmd worktree list --porcelain)

  die "No worktree found for '$input'."
}

cmd_list() {
  git_cmd worktree list "$@"
}

cmd_create() {
  local branch=""
  local start_point=""
  local target_path=""
  local force_flag=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --path)
        [[ $# -ge 2 ]] || die "--path requires a directory."
        target_path="$2"
        shift 2
        ;;
      --from)
        [[ $# -ge 2 ]] || die "--from requires a ref."
        start_point="$2"
        shift 2
        ;;
      --force)
        force_flag=(--force)
        shift
        ;;
      --help|-h)
        print_usage
        exit 0
        ;;
      -*)
        die "Unknown option '$1' for create."
        ;;
      *)
        if [[ -n "$branch" ]]; then
          die "Multiple branch names provided."
        fi
        branch="$1"
        shift
        ;;
    esac
  done

  [[ -n "$branch" ]] || die "Branch name is required."

  if [[ -z "$target_path" ]]; then
    target_path="$WORKTREE_BASE_DIR/$(sanitize_path "$branch")"
  elif [[ "$target_path" != /* ]]; then
    target_path="$WORKTREE_BASE_DIR/$target_path"
  fi

  [[ ! -e "$target_path" ]] || die "Target path '$target_path' already exists."

  local add_args=("${force_flag[@]}")

  if git_cmd show-ref --verify --quiet "refs/heads/$branch"; then
    git_cmd worktree add "${add_args[@]}" "$target_path" "$branch"
    return
  fi

  if [[ -z "$start_point" ]]; then
    if git_cmd show-ref --verify --quiet "refs/remotes/origin/$branch"; then
      start_point="origin/$branch"
    else
      start_point="$(default_start_point)"
    fi
  fi

  add_args+=(-b "$branch")
  git_cmd worktree add "${add_args[@]}" "$target_path" "$start_point"
}

cmd_remove() {
  local force_flag=()
  local target=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force)
        force_flag=(--force)
        shift
        ;;
      --help|-h)
        print_usage
        exit 0
        ;;
      -*)
        die "Unknown option '$1' for remove."
        ;;
      *)
        if [[ -n "$target" ]]; then
          die "Multiple targets provided."
        fi
        target="$1"
        shift
        ;;
    esac
  done

  [[ -n "$target" ]] || die "Worktree path or branch is required."

  local resolved
  resolved="$(resolve_worktree_path "$target")"

  git_cmd worktree remove "${force_flag[@]}" "$resolved"
}

cmd_move() {
  [[ $# -ge 1 ]] || die "Source worktree is required."
  local source="$1"
  shift
  [[ $# -ge 1 ]] || die "Destination path is required."
  local destination="$1"

  local resolved_source
  resolved_source="$(resolve_worktree_path "$source")"

  if [[ "$destination" != /* ]]; then
    destination="$WORKTREE_BASE_DIR/$destination"
  fi

  git_cmd worktree move "$resolved_source" "$destination"
}

cmd_prune() {
  git_cmd worktree prune "$@"
}

cmd_init() {
  local target="${1:-$PWD}"

  if [[ "$target" != /* ]]; then
    target="$PWD/$target"
  fi

  mkdir -p "$target" || die "Failed to create directory '$target'."

  local absolute
  absolute="$(cd "$target" && pwd)"

  local marker="$absolute/.wt"

  if [[ -e "$marker" && ! -f "$marker" ]]; then
    die "Cannot place marker at '$marker'; remove or rename the existing entry."
  fi

  cat >"$marker" <<EOF
# wt base marker
base=$absolute
repo=$REPO_DIR
EOF

  printf '%s\n' "$absolute" >"$CONFIG_FILE"
  WORKTREE_BASE_DIR="$absolute"
  echo "Marked $absolute for new worktrees."

  if [[ -n "${WORKTREE_BASE:-}" ]]; then
    echo "$SCRIPT_NAME: Note: WORKTREE_BASE is set; it overrides the saved directory for this invocation." >&2
  fi
}

main() {
  local command="${1:-help}"
  shift || true

  case "$command" in
    list|ls|l)
      cmd_list "$@"
      ;;
    create|add|new|c)
      cmd_create "$@"
      ;;
    remove|rm|delete|del|r)
      cmd_remove "$@"
      ;;
    move|mv|update|m)
      cmd_move "$@"
      ;;
    prune|p)
      cmd_prune "$@"
      ;;
    init)
      cmd_init "$@"
      ;;
    help|-h|--help)
      print_usage
      ;;
    *)
      die "Unknown command '$command'. Run '$SCRIPT_NAME help' for usage."
      ;;
  esac
}

main "$@"
