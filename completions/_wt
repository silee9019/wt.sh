#compdef wt

local _wt_marker_cache_dir=""
local _wt_marker_cache_repo=""

_wt_trim_whitespace() {
  local str="$1"
  str="${str#"${str%%[![:space:]]*}"}"
  str="${str%"${str##*[![:space:]]}"}"
  REPLY="$str"
}

_wt_find_marker_base() {
  local dir=$PWD
  while [[ $dir != "/" ]]; do
    if [[ -f "$dir/.wt" ]]; then
      REPLY=$dir
      return 0
    fi
    dir=${dir:h}
  done
  return 1
}

_wt_parse_marker_value() {
  local key=$1
  local marker
  if ! _wt_find_marker_base; then
    return 1
  fi
  marker="$REPLY/.wt"
  local value
  value=$(awk -v KEY="$key" '
    /^[[:space:]]*#/ { next }
    /^[[:space:]]*$/ { next }
    {
      sub(/\r$/, "", $0)
    }
    $0 ~ "^[[:space:]]*" KEY ":" {
      sub("^[[:space:]]*" KEY ":[[:space:]]*", "", $0)
      print
      exit
    }
  ' "$marker" 2>/dev/null)
  if [[ -n "$value" ]]; then
    REPLY=$value
    return 0
  fi
  return 1
}

_wt_repo_dir() {
  if [[ -n "$_wt_marker_cache_repo" && -n "$_wt_marker_cache_dir" ]]; then
    if [[ "$PWD" == $_wt_marker_cache_dir* ]]; then
      REPLY=$_wt_marker_cache_repo
      return 0
    fi
  fi

  local base repo
  if ! _wt_find_marker_base; then
    return 1
  fi
  base=$REPLY

  local resolved_base
  if ! resolved_base="$(builtin cd "$base" 2>/dev/null && pwd)"; then
    return 1
  fi

  if ! _wt_parse_marker_value repo; then
    return 1
  fi
  repo=$REPLY
  _wt_trim_whitespace "$repo"
  repo=$REPLY

  if [[ "$repo" == "~"* ]]; then
    repo=${~repo}
  fi

  if [[ "$repo" != /* ]]; then
    repo="$resolved_base/$repo"
  fi

  local resolved_repo
  if ! resolved_repo="$(builtin cd "$repo" 2>/dev/null && pwd)"; then
    return 1
  fi

  _wt_marker_cache_dir="$resolved_base"
  _wt_marker_cache_repo="$resolved_repo"
  REPLY="$resolved_repo"
  return 0
}

_wt_relative_paths() {
  local base
  if _wt_find_marker_base; then
    base=$REPLY
    _files -W "$base" -/
  else
    _files -/
  fi
}

_wt_repository_paths() {
  _files -/
}

_wt_worktree_dirs() {
  local base
  if ! _wt_find_marker_base; then
    return 1
  fi
  base=$REPLY
  local -a paths entries
  paths=("${(@f)$(wt list --porcelain 2>/dev/null | awk '/^worktree /{print $2}')}")
  (( $#paths )) || return 1

  local path rel desc
  for path in $paths; do
    if [[ "$path" == "$base" ]]; then
      continue
    elif [[ "$path" == ${base}/* ]]; then
      rel=${path#$base/}
      desc=$path
    else
      rel=$path
      desc=$path
    fi
    entries+=("$rel:$desc")
  done

  _describe -t worktrees 'worktree directory' entries
}

_wt_git_refs() {
  local repo
  if ! _wt_repo_dir; then
    return 1
  fi
  repo=$REPLY
  local head
  head=$(git -C "$repo" symbolic-ref --quiet --short HEAD 2>/dev/null)
  local -a raw_refs entries
  raw_refs=("${(@f)$(git -C "$repo" for-each-ref --format='%(refname:short)%09%(refname)' refs/heads refs/remotes 2>/dev/null)}")
  (( $#raw_refs )) || return 1

  local ref details name branch_desc
  for ref in $raw_refs; do
    name="${ref%%$'\t'*}"
    details="${ref#*$'\t'}"
    branch_desc="branch"
    if [[ "$details" == refs/heads/* ]]; then
      branch_desc="local branch"
    elif [[ "$details" == refs/remotes/* ]]; then
      branch_desc="remote branch"
    fi
    if [[ -n "$head" && "$name" == "$head" ]]; then
      branch_desc="* current branch"
    fi
    entries+=("$name:$branch_desc")
  done

  _describe -t wt-git-refs 'git ref' entries "$@"
}

typeset -A _wt_alias_map=(
  [ls]=list
  [rm]=remove
  [mv]=move
  [-h]=help
  [--help]=help
)

_wt_primary_commands=(
  'list:List registered worktree directories'
  'add:Create a new worktree'
  'remove:Remove a worktree directory'
  'move:Move or rename a worktree directory'
  'prune:Prune stale worktree metadata'
  'init:Mark or update the worktree base directory'
  'help:Show help'
  'ls:List registered worktree directories'
  'rm:Remove a worktree directory'
  'mv:Move or rename a worktree directory'
)

_wt_option_entries=(
  '-h:Show help'
  '--help:Show help'
)

_wt_all_command_entries=(
  "${_wt_primary_commands[@]}"
  "${_wt_option_entries[@]}"
)

_wt_resolved_command() {
  local candidate=$1
  if [[ -n ${_wt_alias_map[$candidate]} ]]; then
    REPLY=${_wt_alias_map[$candidate]}
  else
    REPLY=$candidate
  fi
}

_wt() {
  local curcontext="$curcontext" state ret=1
  typeset -A opt_args

  _arguments -C \
    '1:command:->cmds' \
    '*::arg:->args' && ret=0

  case $state in
    cmds)
      _describe -t wt-commands 'wt command' _wt_all_command_entries
      ret=0
      ;;
    args)
      local cmd=${words[2]}
      [[ -z $cmd ]] && return ret
      _wt_resolved_command "$cmd"
      cmd=$REPLY
      case $cmd in
        list)
          _arguments \
            '--porcelain[Output in porcelain format]' \
            '--help[Show usage information]' && ret=0
          ;;
        add)
          _arguments -C \
            '--path[Directory for the new worktree]:directory:_wt_relative_paths' \
            '--from[Starting point for the branch]:ref:_wt_git_refs' \
            '--help[Show usage information]' \
            '1:branch name:_wt_git_refs' \
            '2::directory:_wt_relative_paths' && ret=0
          ;;
        remove)
          _arguments \
            '--help[Show usage information]' \
            '1:worktree directory:_wt_worktree_dirs' && ret=0
          ;;
        move)
          _arguments \
            '--help[Show usage information]' \
            '1:worktree directory:_wt_worktree_dirs' \
            '2:destination directory:_wt_relative_paths' && ret=0
          ;;
        prune)
          _arguments \
            '--dry-run[Report what would be pruned]' \
            '--help[Show usage information]' && ret=0
          ;;
        init)
          _arguments \
            '--repo[Explicit repository path]:repository:_wt_repository_paths' \
            '--help[Show usage information]' \
            '1::base directory:_files -/' && ret=0
          ;;
        help)
          _describe -t wt-help-commands 'wt command' _wt_all_command_entries
          ret=0
          ;;
        *)
          ret=1
          ;;
      esac
      ;;
  esac

  return ret
}

_wt "$@"
